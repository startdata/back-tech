## Key

### 사용하는 이유

- 엘리먼트에 안정적인 고유성을 부여하기 위해 배열 내부의 엘리먼트에 지정해야 한다.
- 고유하게 식별할 수 있는 문자열을 사용하고 대부분 데이터의 ID를 key로 사용한다.
- 전체 범위에서 고유할 필요 없다. 형제 사이에서 고유해야 한다.

---

### key로 사용하는 문자

- 데이터의 ID
- 인덱스

인덱스의 경우 안정 적인 ID값이 없는 경우 인덱스를 사용하고
항목의 순서가 바뀔 수 있는 경우 인덱스를 사용하지 않는다.

## key 항목의 순서가 바뀌는 경우

배열을 추가하고 배열을 화면에서 조회할때 배열의 뒤의 값으로 추가되는 경우 문제가 없지만 앞으로 데이터가 들어오는경우 0번의 데이터가 변환하지 않고 마지막 데이터가 중복으로 조회된다.

---

## Hook

함수형 컴포넌트에서 컴포넌트의 생명주기에 맞춰 코드가 실행되도록 하기 위해 사용

> 원래 존재하는 어떤 기능에 마치 갈고리를 거는 것처럼 끼어 들어가 같이 수행되는 것
> 리액트의 state와 생명주기 기능에 갈고리를 걸어 원하는 시점에 정해진 함수를 실행되도록 만든 것

---

## useState

state를 사용하기 위한 훅

> const [변수명, set변수명] = useState(초기값);

---

## useEffect

사이드 이펙트를 수행하기 위한 훅
프로그래밍에서의 부정적 원가 아닌 효과

---

## 생명주기

### 생성시점(출생)

> 마운트: 컴포넌트가 생성됨 (출생)

- 컴포넌트 생성자 실행
- state 정의
- componentDidMount() 함수 호출

### 업데이트(일생)

> 업데이트: 컴포넌트가 여러 번 렌더링

- 컴포넌트 props 변경,setState()함수호출 state 변경
- forceUpdate() 함수 호출 이후 다시 렌더링

### 사망

> 언마운트: 컴포넌트가 사라지는 과정

> 상위 컴포넌트에서 현재 컴포넌트를 더 이상 화면에 표시하지 않게 될때 언마운트

- 언마운트 직전에 componentWillUnmount() 함수 호출

### 중요

컴포넌트가 계속 존재하는 것이 아닌 생성되고 업데이트되다가 사라진다.

## useCallBack, useMemo의 차이

### 공통

메모이제이션

### useCallBack

메모이제이션된 '함수'를 반환한다.
deps가 변하면 새로운 함수를 반환한다.

새로고침 이후에에는 이전 함수와 새로운 함수는 다른 함수이다.

### useMemo

메모이제이션된 '값'을 반환한다.
deps가 변하면 함수가 실행되고 그 함수의 반환 값을 반환한다.

---

### useRef

레퍼런스를 사용하기 위한 훅이다.
레퍼런스랑 특정 컴포넌트에 접근할 수 있는 객체이다.
.current라는 속성이 있고 참조하고 있는 엘리먼트를 의미한다.
초기값이 null이면 컴포넌트가 마운트 해제 전까지 계속 유지된다.

> useRef() 훅은 변경 가능한 .current라는 속성을 가진 하나의 상자

useRef 훅은 일반적인 자바스크립트 객체를 반환한다.
훅을 사용하는것은 매번 렌더링될 때마다 항상 같은 ref객체를 반환한다.

### hook 규칙

- 훅은 무조건 최상위 레벨 에서만 호출해야 함
- 반복문,조건문,중첩된 함수들 안에서 훅을 호출할수 없다
- 훅은 컴퍼넌트가 렌더링 될때마다 매번 같은 순서로 호출되어야 한다.
- 리액트 함수 컴포넌트에서 훅을 호출해야 함
- 커스텀 훅에서 호출가능
