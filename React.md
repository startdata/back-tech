## Key

### 사용하는 이유

- 엘리먼트에 안정적인 고유성을 부여하기 위해 배열 내부의 엘리먼트에 지정해야 한다.
- 고유하게 식별할 수 있는 문자열을 사용하고 대부분 데이터의 ID를 key로 사용한다.
- 전체 범위에서 고유할 필요 없다. 형제 사이에서 고유해야 한다.

---

### key로 사용하는 문자

- 데이터의 ID
- 인덱스

인덱스의 경우 안정 적인 ID값이 없는 경우 인덱스를 사용하고
항목의 순서가 바뀔 수 있는 경우 인덱스를 사용하지 않는다.

---

## Hook

함수형 컴포넌트에서 컴포넌트의 생명주기에 맞춰 코드가 실행되도록 하기 위해 사용

> 원래 존재하는 어떤 기능에 마치 갈고리를 거는 것처럼 끼어 들어가 같이 수행되는 것
> 리액트의 state와 생명주기 기능에 갈고리를 걸어 원하는 시점에 정해진 함수를 실행되도록 만든 것

---

## useState

state를 사용하기 위한 훅

> const [변수명, set변수명] = useState(초기값);

---

## useEffect

사이드 이펙트를 수행하기 위한 훅
프로그래밍에서의 부정적 원가 아닌 효과

---

## 생명주기

### 생성시점(출생)

> 마운트: 컴포넌트가 생성됨 (출생)

- 컴포넌트 생성자 실행
- state 정의
- componentDidMount() 함수 호출

### 업데이트(일생)

> 업데이트: 컴포넌트가 여러 번 렌더링

- 컴포넌트 props 변경,setState()함수호출 state 변경
- forceUpdate() 함수 호출 이후 다시 렌더링

### 사망

> 언마운트: 컴포넌트가 사라지는 과정

> 상위 컴포넌트에서 현재 컴포넌트를 더 이상 화면에 표시하지 않게 될때 언마운트

- 언마운트 직전에 componentWillUnmount() 함수 호출

### 중요

컴포넌트가 계속 존재하는 것이 아닌 생성되고 업데이트되다가 사라진다.

## useCallBack, useMemo의 차이

### 공통

메모이제이션

### useCallBack

메모이제이션된 '함수'를 반환한다.
deps가 변하면 새로운 함수를 반환한다.

새로고침 이후에에는 이전 함수와 새로운 함수는 다른 함수이다.

### useMemo

메모이제이션된 '값'을 반환한다.
deps가 변하면 함수가 실행되고 그 함수의 반환 값을 반환한다.
